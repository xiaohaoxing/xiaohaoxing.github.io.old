<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  
  
  <title>  XHX 博客 </title>

 
  
    <link rel="icon" href="/images/favicon.ico">
  


  <link rel="stylesheet" href="/nayo.min.css"> 
</head>  
  <body>   
    
      <header class="header">
	
  <nav class="header-nav">        

    <span class="iconfont icon-menu mobile-toggle"></span>   	

    <div class="header-logo">
      <a href="/">
        <img class="header-logo-img" src="/images/head.JPG">
      </a>
    </div>

    <div class="header-menu">          
              
          
            <a class="header-menu-link" id="header-menu-home" href="/">
              <i class="iconfont icon-home">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-archives" href="/archives">
              <i class="iconfont icon-archives">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-tags" href="/tags">
              <i class="iconfont icon-tags">  
            </i></a>     
          
              
          
            <a class="header-menu-link" id="header-menu-about" href="/about">
              <i class="iconfont icon-about">  
            </i></a>     
          
              
          
              <a class="header-menu-link" id="header-menu-search">
                <i class="iconfont icon-search">  
              </i></a>
          
                  
    </div>  
    
  </nav>
</header>

   

      <div class="container">       
          
          
            <section class="main">  
          

          




<div class="profile sildeUpMin">
	
		<img class="avatar" src="/images/head.JPG">

		<p class="author">XiaoHaoxing</p>
		
		<div class="social">
   		      	
			<a target="_blank" class="social-links" href="https://github.com/xiaohaoxing">		
				<i class="iconfont icon-Github">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://weibo.com/1867341073/profile">		
				<i class="iconfont icon-Weibo">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://www.facebook.com/xiao.haoxing.7">		
				<i class="iconfont icon-Facebook">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://www.instagram.com/xiao.haoxing.7/">		
				<i class="iconfont icon-Instagram">
			</i></a>	
	          	
			<a target="_blank" class="social-links" href="https://music.163.com/#/user/home?id=77638723">		
				<i class="iconfont icon-Neteasemusic">
			</i></a>	
	    
    	</div>		
</div>


    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2018/09/26/java-如何选择最具体的方法执行（翻译）/">java 如何选择最具体的方法执行（翻译）</a>  
	       
		 

		<div class="article-meta">
			<time>Sep 26, 2018</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/java/">java</a>           
				            
						<a class="article-tag" href="/tags/jls/">jls</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p>  方法调用的时候，有2个以上的成员方法都是可访问且适配，就必须要为运行时选择一个方法描述符。Java 语言选择的规则是：最具体的方法。</p>
<p>  简单讲就是在方法调用传递的时候不会产生任何编译时错误的前提下，一个方法比另一个方法更具体。在参数确定的 lambda 表达式或原始数据类型调用的情况下，签名可以灵活调整。</p>
<p>  设方法调用的参数表达为：$$e_1, …, e_k$$，如果一个适配的方法 $$m_1$$ 比另一个适配的方法 $$m_2$$ 更具体，需要满足以下任一个条件：</p>
<ol>
<li><p>$$m_2$$ 是泛方法，那么 $$m_1$$ 在参数 $$e_1, …, e_k$$ 上比 $$m_2$$ 更具体。(见18.5.4)</p>
</li>
<li><p>$$m_2$$ 不是泛方法，$$m_1$$ 和 $$m_2$$ 对于调用的适配有的宽松有的严格，$$m_1$$参数类型：$$S_1, …, S_n$$，$$m_2$$ 参数类型：$$T_1, …, T_n$$，每一个 $$e_i$$ 都有 $$S_i$$ 比 $$T_i$$ 更具体。</p>
</li>
<li><p>$$m_2$$ 不是泛方法，$$m_1$$ 和 $$m_2$$ 都适配原始类型做参数的方法调用，$$m_1$$ 的前 k 个变量参数是：$$S_1, …, S_k$$，$$m_2$$ 的前 k 个变量参数是：$$T_1, …, T_k$$，对每一个 $$e_i$$ 都有 $$S_i$$ 比 $$T_i$$ 更具体。但是 $$m_1$$ 的第 k + 1个参数是 $$m_2$$ 的子类型。</p>
</li>
</ol>
<p>上述条件仅适用于一个方法比另一个方法更具体的情况。</p>
<p>如果 $$S &lt;: T$$那么 S 比 T 类型更具体。(参见JLS4.10)</p>
<p>对于表达式 e， 如果 T 不是 S 的子类型，满足以下条件时，接口类型 S 才会比接口类型 T 更具体：</p>
<blockquote>
<p>设 $$U_1, …, U_k$$ 和 $$R_1$$ 分别是方法 S 的参数类型和返回类型；$$V_1, …, V_k$$ 和 $$R_2$$ 分别是方法 T 的参数类型和返回值类型。</p>
</blockquote>
<ul>
<li>如果 e 是特定类型的 labmda 表达式，那么下面一项成立：<ul>
<li>$$R_2$$ 是void</li>
<li>$$R_1 &lt;: R_2$$</li>
<li>$$R_1$$ 和 $$R_2$$ 是接口类型，至少有一个 return，且每个 e 的 return 都有$$R_1$$ 比 $$R_2$$ 更具体。<br>(代码块方法体的 lambda 表达式的 return 在15.27.2定义。表达式方法体的 lambda 表达式的 return 就是自身。)</li>
<li>$$R_1$$ 是原始类型，$$R_2$$ 是引用类型，至少存在一个 return，且每个 e 的 return 是独立的原始类型的表达式。</li>
<li>$$R_1$$是引用类型，$$R_2$$是原始类型，至少存在一个 return，且每个 e 的 return 是独立的引用类型表达式或[多项表达式][2]<br>(多项表达式这里的含义可以一句话总结：根据不同的输入情况，输出结果可能有不同的数据类型)</li>
</ul>
</li>
<li>如果 e 是复合表达式，情况中的一种递归应用到包含的表达式中。</li>
<li>如果 e 是条件表达式，对每第二个和第三个操作递归操作。</li>
</ul>
<p>方法 $$m_1$$ 比方法 $$m_2$$ 严格具体，当且仅当 $$m_1$$ 比 $$m_2$$ 更具体且 $$m_2$$ 不比 $$m_1$$更具体。</p>
<p>方法对于方法调用<code>最大具体</code>：可访问性和适配度没有比它更严格具体的。</p>
<p>如果只有一个<code>最大具体</code>的方法，那么就叫方法调用<code>最具体</code>的方法，这个最具体的方法肯定比其他可访问的适配的方法。接下来就是其他的编译时的检查的任务了，参见15.12.3。</p>
<p>也有可能找不到最具体的方法，可能存在多个方法是最大具体。这种情况：</p>
<ul>
<li>如果所有最大具体的方法都有<a href="#appendix">等价继承的签名</a>:<ul>
<li>如果只有一个方法是具体的(非 <code>abstract</code>的)，那它就是最具体的方法。</li>
<li>否则，如果所有的方法都是 abstract 或者默认的，所有的方法签名都有相同的擦除，那就直接取返回值最具体的那个方法。<br>这种情况下，最具体的方法可能是 abstract 的。最具体的方法可能抛出检查异常当且仅当异常或者擦除在每个最大具体方法的 throws 从句中声明。</li>
</ul>
</li>
<li>否则，方法调用就是<code>ambiguous</code>的，编译时错误抛出。</li>
</ul>
<p><a name="appendix"></a></p>
<p>##Appendix：</p>
<ol>
<li><p>继承等价的签名:</p>
<p> A 擦除后和 B 相同，则 A 是 B 的子方法签名，B 擦除后也和 A 相同，则两者继承等价。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❌同一个类里的继承等价会导致编译时错误。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionConverter</span> </span>&#123;</span><br><span class="line">    <span class="function">List <span class="title">toList</span><span class="params">(Collection c)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overrider</span> <span class="keyword">extends</span> <span class="title">CollectionConverter</span> </span>&#123;</span><br><span class="line">    <span class="function">List <span class="title">toList</span><span class="params">(Collection c)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>❗️这里的 CollectionConverter 如果修改就会导致 Overrider 代码出错。<br></p>
<p>##References:<br>[1]: <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5</a> Choosing the Most Specific Method<br>[2]: <a href="http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/D.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/D.html</a> Lambda Specification, Part D: Poly Expressions<br>[3]: <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2</a> Method Signature</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2018/09/26/java-如何选择最具体的方法执行（翻译）/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2018/09/26/Java-Interface一个知识点/">Java Interface一个知识点</a>  
	       
		 

		<div class="article-meta">
			<time>Sep 26, 2018</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/Java/">Java</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>   最近在看 Tomcat 实现相关的书籍，阅读到这样一句：“若只使用如下语句，编译器就无法知道要调用哪个构造函数，并且会报错：new URL(null, str, null)” 。就忽然想去探究一下编译器在考虑有继承的类作为参数的函数执行过程的逻辑。于是就有了这篇文章。</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>   考虑如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Parent obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with Parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Son obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//test1</span></span><br><span class="line">        test(<span class="keyword">new</span> Parent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   这里输出是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method with Parent</span><br></pre></td></tr></table></figure></p>
<p>   这里应该不用解释了，new 出来的就是一个 Parent 对象，因此调用的自然是 Parent 为参数的方法。</p>
<hr>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>   考虑如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//test2</span></span><br><span class="line">    Parent p = <span class="keyword">new</span> Son();</span><br><span class="line">    test(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   这里输出是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method with Parent</span><br></pre></td></tr></table></figure></p>
<p>   变量 p 声明的类型是 Parent，因此虽然它 new 的时候是Son，但是在传递值给 p 的时候已经擦除为 Parent 类型了，在后面，除非主动转换(显式转换)类型，不然它是 Son 的真相就被雪藏了。所以这里 test 方法只知道它是 Parent，因此调用的是 Parent 为参数的方法。</p>
<hr>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>   考虑如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   这里输出是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method with Son</span><br></pre></td></tr></table></figure></p>
<p>   这里开始就很有意思了，这一部分为什么会输出 Son 呢？2个 test 难道不是都符合条件？这里参考了文章[Java函数重载和精准度匹配][1]，简单说就是因为参数为 Son 的函数比参数为 Parent 的函数更精确。不过文章并没有深入去探究原因，后续计划有时间去查 Java 运行时的原理。<br>   通过查看编译后的字节码，可以得到的信息：Java 编译器在编译时就已经确定<code>test(null)</code>要执行的是 <code>test(Son)</code> 这个函数，指向的函数引用已经是test(Son)，甚至test(Parent)都没有放到 ConstantPool 里面。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>   考虑如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Parent obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with Parent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Son obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Daughter obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with Daughter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   这里输出是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Ambiguous method call. Both test(Son) in InterfaceTest and test(Daughter) in InterfaceTest match.</span><br></pre></td></tr></table></figure></p>
<p>   这里出现异常了。是因为调用的 test 方法存在二义性：test(Son) 和 test(Daughter) 都满足条件，无法判断调用哪一个。</p>
<hr>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>   其实这部分最重要的知识点就是：在可以选择多个执行方法的时候，编译器如何选择？答案是：选择一个最具体的函数执行。具体执行过程参见文章：<a href="/2018/09/26/java-如何选择最具体的方法执行（翻译）/">java 如何选择最具体的方法执行（翻译）</a></p>
<p>参考资料：<br>[1]: <a href="https://blog.csdn.net/smartyidiot/article/details/7464454" target="_blank" rel="noopener">https://blog.csdn.net/smartyidiot/article/details/7464454</a> Java函数重载及精准度匹配</p>
<p>[2]: <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5</a> Choosing the Most Specific Method</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2018/09/26/Java-Interface一个知识点/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2018/07/02/Mac-OS上搭建虚拟机集群/">Mac OS上搭建网络连通的虚拟机集群😊</a>  
	       
		 

		<div class="article-meta">
			<time>Jul 02, 2018</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/虚拟机/">虚拟机</a>           
				            
						<a class="article-tag" href="/tags/计算机网络/">计算机网络</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<h1 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h1><p>​    最近看了一些 Hadoop 相关的书籍和文章，想实现 zookeeper 的一个 demo，因此就需要在本地搭建一个 Linux 的虚拟服务器集群，这篇文章就是针对本地虚拟机的配置。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2018/07/02/Mac-OS上搭建虚拟机集群/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2018/06/13/React实现异步加载数据/">React实现异步加载数据</a>  
	       
		 

		<div class="article-meta">
			<time>Jun 13, 2018</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/前端/">前端</a>           
				            
						<a class="article-tag" href="/tags/React/">React</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<h1 id="零、引言"><a href="#零、引言" class="headerlink" title="零、引言"></a>零、引言</h1><p>​    熟悉了 React 编写组件的方式，我们自然就想到了一个实际工程中非常常见的一个需求：网络条件差、而请求数据量大的时候，需要的是页面先显示出来，然后异步请求数据填充进去。这样用户体验会更好。<br>
		  	  
	</p></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2018/06/13/React实现异步加载数据/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2018/06/11/First-React-Project/">First React Project</a>  
	       
		 

		<div class="article-meta">
			<time>Jun 11, 2018</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/前端/">前端</a>           
				            
						<a class="article-tag" href="/tags/React/">React</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		
			<h1 id="零、前提要求"><a href="#零、前提要求" class="headerlink" title="零、前提要求"></a>零、前提要求</h1><p>​    React 的开发和传统前端开发并不相同，因此要求也更高，这里我个人认为需要做到下面步骤不会懵逼，至少需要：</p>
<ol>
<li>能独立用传统 HTML+CSS 构建简单的 web 页面，不要求美观，至少能按照要求任意调整布局。</li>
<li>了解现代化的 flex 布局。</li>
<li>会写 JS 事件，对 ES6中的面向对象和模块化有理解。</li>
<li>简单的命令行操作以及了解 node 和 npm 一些命令。</li>
<li>React 入门，推荐博客：<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="noopener">阮一峰 React 教程</a>，内容不多，但是很实用。
		  	  
	</li></ol></div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2018/06/11/First-React-Project/">阅读更多</a> 	
	</div>	
    
</article>     
     	
    	  	
  		
    			

<article class="article">		
	   
	<div class="article-header">
	    
		<a class="article-title" href="/2018/01/13/使用Hexo在github-io搭建博客/">使用Hexo在github.io搭建博客</a>  
	       
		 

		<div class="article-meta">
			<time>Jan 13, 2018</time>
			
				<span class="iconfont icon-star"></span>
				            
						<a class="article-tag" href="/tags/日常/">日常</a>           
				
			
		</div>
	</div>


	

    
	<div class="typo article-excerpt">	
		 
			<p>受学长影响接触到Hexo，加上之前在<a href="xiaohaoxing.github.io">github.io</a>上经常测试一些前端的小例子，于是决定使用Hexo在github上搭建一个博客。</p>
<p>以后这里主要写编程相关的一些记录，以备后续检索。</p>

		  	  
	</div>

	<div class="article-bottom">
		<a class="article-readmore" href="/2018/01/13/使用Hexo在github-io搭建博客/">阅读更多</a> 	
	</div>	
    
</article>     
     	




          </section> 
      </div>            
    
    <a id="backTop">
      <span>
        <i class="iconfont icon-backtotop"></i>
      </span>
    </a> 

  
    
    <div class="search-container sildeUpMin">
        <div class="search-header">
            <input type="text" placeholder="输入你想搜索的" id="search-input" class="search-input">
            <span class="search-cancel">
                <i class="iconfont icon-cancel">
            </i></span>
        </div>
        <div id="search-result" class="search-result"></div>
    </div>
 
     <div class="mobile-menu">      

      
      <img class="mobile-menu-icon" src="/images/favicon.ico">   
      

         
            

            <a class="mobile-menu-link" href="/">首页
            </a>
            
         
            

            <a class="mobile-menu-link" href="/archives">归档
            </a>
            
         
            

            <a class="mobile-menu-link" href="/tags">标签
            </a>
            
         
            

            <a class="mobile-menu-link" href="/about">关于
            </a>
            
         
                          

            <a class="mobile-menu-link mobile-menu-search" href="#">搜索 </a>                 
            
         
      
</div>        
    



     
    




<footer id="footer">	    

		
		<div class="footer-copyright">
		&copy;
		
		2018		
	
		XiaoHaoxing
		<br>

		Theme By
		<a href="https://github.com/Lemonreds/hexo-theme-Nayo" target="_blank">Nayo</a>	
		</div>			
		<script src="https://s19.cnzz.com/z_stat.php?id=1274862886&web_id=1274862886" language="JavaScript"></script>
</footer>   

  

    <script src="/nayo.bundle.js"></script>           
  </body>        
</html>